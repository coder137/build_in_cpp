/*
 * Copyright 2021 Niket Naidu. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "target/target.h"

#include "env/assert_fatal.h"
#include "env/util.h"
#include "target/util.h"

namespace {

constexpr const char *const kFormat = R"(// Generated by BuildCC
#pragma once

// clang-format off
{aggregated_includes}
)";

void AggregateToFile(const fs::path &filename,
                     const buildcc::internal::fs_unordered_set &header_files) {
  std::string aggregated_includes;
  for (const auto &hf : header_files) {
    std::string temp = fmt::format("#include \"{}\"\r\n", hf.string());
    aggregated_includes.append(temp);
  }

  buildcc::Command command;
  std::string constructed_output = command.Construct(
      kFormat, {
                   {"aggregated_includes", aggregated_includes},
               });
  bool success = buildcc::env::SaveFile(filename.string().c_str(),
                                        constructed_output, false);
  buildcc::env::assert_fatal(success, "Could not save pch file");
}

} // namespace

namespace buildcc::base {

std::string Target::ConstructPchCompileCommand() const {
  const std::string compiler = GetState().contains_cpp_src
                                   ? GetToolchain().GetCppCompiler()
                                   : GetToolchain().GetCCompiler();
  const FileExt::Type file_ext_type =
      GetState().contains_cpp_src ? FileExt::Type::Cpp : FileExt::Type::C;
  const std::string compile_flags =
      ext_.GetCompileFlags(file_ext_type).value_or("");
  return command_.Construct(
      config_.pch_command,
      {
          {"compiler", compiler},
          {"pch_flags", internal::aggregate(GetCurrentPchFlags())},
          {"compile_flags", compile_flags},
          {"output", GetPchCompilePath().string()},
          {"input", GetPchHeaderPath().string()},
      });
}

void Target::PrePchCompile() { storer_.current_pch_files.Convert(); }

void Target::BuildPchCompile() {
  PrePchCompile();
  if (!loader_.IsLoaded()) {
    dirty_ = true;
  } else {
    RecheckFlags(loader_.GetLoadedPreprocessorFlags(),
                 GetCurrentPreprocessorFlags());
    RecheckFlags(loader_.GetLoadedCommonCompileFlags(),
                 GetCurrentCommonCompileFlags());
    RecheckFlags(loader_.GetLoadedPchFlags(), GetCurrentPchFlags());
    RecheckFlags(loader_.GetLoadedCCompileFlags(), GetCurrentCCompileFlags());
    RecheckFlags(loader_.GetLoadedCppCompileFlags(),
                 GetCurrentCppCompileFlags());
    RecheckDirs(loader_.GetLoadedIncludeDirs(), GetCurrentIncludeDirs());
    RecheckPaths(loader_.GetLoadedHeaders(),
                 storer_.current_header_files.internal);
    RecheckPaths(loader_.GetLoadedPchs(), storer_.current_pch_files.internal);
  }

  if (dirty_) {
    AggregateToFile(GetPchHeaderPath(), GetCurrentPchFiles());
    bool success = Command::Execute(pch_file_.command);
    env::assert_fatal(success, "Failed to compile pch");
  }
}

} // namespace buildcc::base
