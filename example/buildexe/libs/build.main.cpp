#include "buildcc.h"

// Included through libs
#include "build.fmt.h"

// Generated by BuildCC
// See the `_build_internal` directory
#include "buildexe_lib_dirs.h"

using namespace buildcc;

constexpr const char *const EXE = "build";

// Function Prototypes
static void clean_cb();
static void hello_world_build_cb(BaseTarget &target, BaseTarget &fmt_lib);

int main(int argc, char **argv) {
  // Get arguments
  ArgToolchain arg_gcc;
  Args::Init()
      .AddToolchain("gcc", "Generic gcc toolchain", arg_gcc)
      .Parse(argc, argv);

  // Initialize your environment
  Reg::Init();

  // Pre-build steps
  Reg::Call(Args::Clean()).Func(clean_cb);

  // Build steps
  // Explicit toolchain - target pairs
  Toolchain_gcc gcc;

  StaticTarget_gcc fmt_lib(
      "libfmt", gcc,
      TargetEnv(BuildExeLibDir::fmt, Project::GetBuildDir() / "fmt"));
  FmtConfig fmt_config;
  ExecutableTarget_gcc hello_world("hello_world", gcc, "");
  Reg::Toolchain(arg_gcc.state)
      .Func([&]() { gcc.Verify(); })
      .Build(build_fmt_cb, fmt_lib, fmt_config)
      .Build(hello_world_build_cb, hello_world, fmt_lib)
      .Dep(hello_world, fmt_lib)
      .Test("{executable}", hello_world);

  // Build Target
  Reg::Run();

  // Post Build steps
  // - Clang Compile Commands
  plugin::ClangCompileCommands({&hello_world}).Generate();
  // - Graphviz dump
  std::cout << Reg::GetTaskflow().dump() << std::endl;

  return 0;
}

static void clean_cb() {
  env::log_info(EXE, fmt::format("Cleaning {}", Project::GetBuildDir()));
  fs::remove_all(Project::GetBuildDir());
}

static void hello_world_build_cb(BaseTarget &target, BaseTarget &fmt_lib) {
  target.AddSource("main.cpp", "src");
  target.AddLibDep(fmt_lib);
  target.Insert(fmt_lib, {
                             SyncOption::IncludeDirs,
                             SyncOption::HeaderFiles,
                         });
  target.Build();
}
